import numpy as np
import pandas as pd
import gymnasium as gym
from gymnasium import spaces
import random
from collections import deque
import gc
# import logging # üî• –£–î–ê–õ–ï–ù–û: –ò–º–ø–æ—Ä—Ç logging

class TradingEnvironment(gym.Env):
    """
    –°—Ä–µ–¥–∞ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –∞–≥–µ–Ω—Ç–∞ —Å –ø–æ–º–æ—â—å—é RL
    –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω—ã–º–∏, —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –ø–æ —Å–∏–º–≤–æ–ª–∞–º
    """
    def __init__(self, data_by_symbol, sequence_length=60, initial_balance=10000, transaction_fee=0.001, max_memory_size=1000):
        super(TradingEnvironment, self).__init__()
        
        # üî• –ò–ó–ú–ï–ù–ï–ù–û: –¢–µ–ø–µ—Ä—å –¥–∞–Ω–Ω—ã–µ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω—ã –ø–æ —Å–∏–º–≤–æ–ª–∞–º
        self.data_by_symbol = data_by_symbol  # –°–ª–æ–≤–∞—Ä—å: symbol -> –º–∞—Å—Å–∏–≤ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π
        self.symbols = list(data_by_symbol.keys())
        self.sequence_length = sequence_length
        self.initial_balance = initial_balance
        self.transaction_fee = transaction_fee
        # üî• –ò–°–ü–†–ê–í–õ–ï–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º deque –≤–º–µ—Å—Ç–æ —Å–ø–∏—Å–∫–∞
        self.memory_buffer = deque(maxlen=max_memory_size)  # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞
        self.step_count = 0  # üî• –î–û–ë–ê–í–õ–ï–ù–û: –°—á–µ—Ç—á–∏–∫ —à–∞–≥–æ–≤
        
        # –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π —Å–∏–º–≤–æ–ª –¥–ª—è –Ω–∞—á–∞–ª–∞
        self.current_symbol = random.choice(self.symbols) if self.symbols else None
        self.current_data = self.data_by_symbol[self.current_symbol] if self.current_symbol else None
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –¥–µ–π—Å—Ç–≤–∏–π: 0 - BUY, 1 - HOLD, 2 - SELL
        self.action_space = spaces.Discrete(3)
        
        # –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –Ω–∞–±–ª—é–¥–µ–Ω–∏–π: —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ü–µ–Ω –∏ –æ–±—ä–µ–º–æ–≤ –ë–ï–ó –ø–æ–∑–∏—Ü–∏–∏
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏—Å—Ö–æ–¥–Ω—É—é —Ñ–æ—Ä–º—É –¥–∞–Ω–Ω—ã—Ö (–±–µ—Ä–µ–º –∏–∑ –ø–µ—Ä–≤–æ–≥–æ —Å–∏–º–≤–æ–ª–∞)
        if self.current_data is not None and len(self.current_data) > 0:
            self.observation_space = spaces.Box(
                low=-np.inf,
                high=np.inf,
                shape=(self.sequence_length, self.current_data.shape[2])
            )
        else:
            # –ó–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç, –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç
            self.observation_space = spaces.Box(
                low=-np.inf,
                high=np.inf,
                shape=(self.sequence_length, 10)  # 10 –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            )
        
        # üî• –£–î–ê–õ–ï–ù–û: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–æ–≥–≥–µ—Ä–∞
        # self.logger = logging.getLogger('trading_env')
        
        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ä–µ–¥—É
        self.reset()
    
    def reset(self, seed=None):
        """–°–±—Ä–∞—Å—ã–≤–∞–µ—Ç —Å—Ä–µ–¥—É –≤ –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ"""
        super().reset(seed=seed)
        
        # üî• –î–û–ë–ê–í–õ–ï–ù–û: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—É—Å—Ç—ã–µ —Å–∏–º–≤–æ–ª—ã
        if not self.symbols or len(self.symbols) == 0:
            print("‚ùå –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏")
            # –°–æ–∑–¥–∞–µ–º dummy –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∫—Ä–∞—Ö–∞
            dummy_shape = (self.sequence_length, 10)  # 10 –ø—Ä–∏–∑–Ω–∞–∫–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            observation = np.zeros(dummy_shape, dtype=np.float32)
            return observation, {}
        
        # –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π —Å–∏–º–≤–æ–ª –ø—Ä–∏ –∫–∞–∂–¥–æ–º —Å–±—Ä–æ—Å–µ
        try:
            self.current_symbol = random.choice(self.symbols)
            self.current_data = self.data_by_symbol[self.current_symbol]
        except (KeyError, IndexError) as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ —Å–∏–º–≤–æ–ª–∞: {e}")
            # Fallback –∫ –ø–µ—Ä–≤–æ–º—É –¥–æ—Å—Ç—É–ø–Ω–æ–º—É —Å–∏–º–≤–æ–ª—É
            if self.symbols:
                self.current_symbol = self.symbols[0]
                self.current_data = self.data_by_symbol.get(self.current_symbol, None)
        
        # üî• –î–û–ë–ê–í–õ–ï–ù–û: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö
        if self.current_data is None or len(self.current_data) == 0:
            print(f"‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–∏–º–≤–æ–ª–∞ {self.current_symbol}")
            dummy_shape = (self.sequence_length, 10)
            observation = np.zeros(dummy_shape, dtype=np.float32)
            return observation, {}
        
        # –°–ª—É—á–∞–π–Ω—ã–π —Å—Ç–∞—Ä—Ç –≤–Ω—É—Ç—Ä–∏ –¥–∞–Ω–Ω—ã—Ö —Å–∏–º–≤–æ–ª–∞
        if self.current_data is not None and len(self.current_data) > self.sequence_length:
            max_start = len(self.current_data) - self.sequence_length
            self.start_index = random.randint(0, max_start)
            self.current_step = self.start_index
        else:
            self.start_index = 0
            self.current_step = 0
        
        self.balance = self.initial_balance
        self.position = 0  # 0 - –Ω–µ—Ç –ø–æ–∑–∏—Ü–∏–∏, 1 - –¥–ª–∏–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è, -1 - –∫–æ—Ä–æ—Ç–∫–∞—è –ø–æ–∑–∏—Ü–∏—è
        self.shares_held = 0
        self.cost_basis = 0
        self.total_trades = 0
        self.total_profit = 0
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–∑–∏—Ü–∏–∏ –∫ –Ω–∞–±–ª—é–¥–µ–Ω–∏—é
        observation = self._get_observation()
        
        return observation, {}
    
    def step(self, action):
        """–í—ã–ø–æ–ª–Ω—è–µ—Ç —à–∞–≥ –≤ —Å—Ä–µ–¥–µ"""
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —à–∞–≥–∞
        if self.current_data is None or self.current_step >= len(self.current_data) - 1:
            # –≠–ø–∏–∑–æ–¥ —É–∂–µ –∑–∞–∫–æ–Ω—á–µ–Ω
            observation = self._get_observation() if self.current_data is not None and self.current_step < len(self.current_data) else np.zeros(self.observation_space.shape)
            info = {
                'balance': float(self.balance),
                'position': self.position,
                'shares_held': float(self.shares_held),
                'total_trades': self.total_trades,
                'total_profit': float(self.total_profit),
                'portfolio_value': float(self.balance),
                'symbol': self.current_symbol  # üî• –î–û–ë–ê–í–õ–ï–ù–û: –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–µ–∫—É—â–µ–º —Å–∏–º–≤–æ–ª–µ
            }
            return observation, 0.0, True, False, info
        
        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É –∑–∞–∫—Ä—ã—Ç–∏—è
        current_price = self._get_current_price()
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è
        max_position_size = self.initial_balance * 0.95  # –ú–∞–∫—Å–∏–º—É–º 95% –æ—Ç –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞
        
        reward = 0
        if action == 0:  # BUY
            if self.position != 1 and self.balance > 0:
                if self.position == -1:
                    reward += self._close_position(current_price)
                
                # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–∫—É–ø–∫–∏
                max_shares = min(max_position_size / current_price, self.balance / (current_price * (1 + self.transaction_fee)))
                shares_to_buy = max_shares * 0.9  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ 90% –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å—Ä–µ–¥—Å—Ç–≤
                
                if shares_to_buy > 0:
                    cost = shares_to_buy * current_price * (1 + self.transaction_fee)
                    
                    if cost <= self.balance:
                        self.balance -= cost
                        self.shares_held = shares_to_buy
                        self.cost_basis = current_price
                        self.position = 1
                        self.total_trades += 1
        
        elif action == 2:  # SELL
            if self.position != -1 and self.balance > 0:
                if self.position == 1:
                    reward += self._close_position(current_price)
                
                # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø—Ä–æ–¥–∞–∂–∏
                max_shares = min(max_position_size / current_price, self.balance / current_price)
                shares_to_sell = max_shares * 0.9  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ 90% –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å—Ä–µ–¥—Å—Ç–≤
                
                if shares_to_sell > 0:
                    self.shares_held = -shares_to_sell
                    self.cost_basis = current_price
                    self.position = -1
                    self.total_trades += 1
        
        # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —à–∞–≥—É
        self.current_step += 1
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–∫–æ–Ω—á–∏–ª—Å—è –ª–∏ —ç–ø–∏–∑–æ–¥
        done = self.current_step >= len(self.current_data) - 1
        
        # –ï—Å–ª–∏ —ç–ø–∏–∑–æ–¥ –∑–∞–∫–æ–Ω—á–∏–ª—Å—è, –∑–∞–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏
        if done and self.position != 0:
            reward += self._close_position(current_price)
        
        # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤–æ–µ –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ
        observation = self._get_observation()
        
        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø–æ—Ä—Ç—Ñ–µ–ª—è —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –Ω–∞ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ
        portfolio_value = self.balance
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ NaN –∏ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç—å
        if np.isnan(self.balance) or np.isinf(self.balance):
            self.balance = self.initial_balance
            portfolio_value = self.initial_balance
            reward = -1.0  # –®—Ç—Ä–∞—Ñ –∑–∞ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ
        
        if self.position == 1 and self.shares_held > 0:
            position_value = self.shares_held * current_price
            if not (np.isnan(position_value) or np.isinf(position_value)):
                portfolio_value += position_value
        elif self.position == -1 and self.shares_held < 0:
            position_value = -self.shares_held * current_price
            if not (np.isnan(position_value) or np.isinf(position_value)):
                portfolio_value -= position_value
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –ø–æ—Ä—Ç—Ñ–µ–ª—å —Ä–∞–∑—É–º–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
        if portfolio_value > self.initial_balance * 1000:  # –ú–∞–∫—Å–∏–º—É–º –≤ 1000 —Ä–∞–∑ –±–æ–ª—å—à–µ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ
            portfolio_value = self.initial_balance * 1000
            reward = -0.5  # –®—Ç—Ä–∞—Ñ –∑–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π —Ä–æ—Å—Ç
        elif portfolio_value < self.initial_balance * 0.001:  # –ú–∏–Ω–∏–º—É–º 0.1% –æ—Ç –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ
            portfolio_value = self.initial_balance * 0.001
            reward = -0.5  # –®—Ç—Ä–∞—Ñ –∑–∞ –±–æ–ª—å—à–∏–µ –ø–æ—Ç–µ—Ä–∏
        
        # üî• –ò–°–ü–†–ê–í–õ–ï–ù–û: –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ deque
        self.memory_buffer.append({
            'state': observation,
            'action': action,
            'reward': reward,
            'done': done,
            'step': self.step_count
        })
        
        self.step_count += 1
        
        # üî• –ò–°–ü–†–ê–í–õ–ï–ù–û: –ú–µ–Ω–µ–µ —á–∞—Å—Ç–∞—è –æ—á–∏—Å—Ç–∫–∞ –ø–∞–º—è—Ç–∏
        if self.step_count % 500 == 0:  # –£–≤–µ–ª–∏—á–µ–Ω–∞ —á–∞—Å—Ç–æ—Ç–∞ —Å 100 –¥–æ 500
            gc.collect()
            print(f"–û—á–∏—Å—Ç–∫–∞ –ø–∞–º—è—Ç–∏ –ø–æ—Å–ª–µ {self.step_count} —à–∞–≥–æ–≤, —Ä–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞: {len(self.memory_buffer)}")
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        info = {
            'balance': float(self.balance) if not (np.isnan(self.balance) or np.isinf(self.balance)) else float(self.initial_balance),
            'position': self.position,
            'shares_held': float(self.shares_held) if not (np.isnan(self.shares_held) or np.isinf(self.shares_held)) else 0.0,
            'total_trades': self.total_trades,
            'total_profit': float(self.total_profit) if not (np.isnan(self.total_profit) or np.isinf(self.total_profit)) else 0.0,
            'portfolio_value': float(portfolio_value),
            'symbol': self.current_symbol  # üî• –î–û–ë–ê–í–õ–ï–ù–û: –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–µ–∫—É—â–µ–º —Å–∏–º–≤–æ–ª–µ
        }
        
        return observation, reward, done, False, info

    def _get_observation(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â–µ–µ –Ω–∞–±–ª—é–¥–µ–Ω–∏–µ"""
        # üî• –ò–ó–ú–ï–ù–ï–ù–û: –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –æ—Ç—Ä–µ–∑–æ–∫ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤–º–µ—Å—Ç–æ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞
        if self.current_data is None or len(self.current_data) == 0:
            return np.zeros(self.observation_space.shape)
        
        # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö
        if len(self.current_data) < self.sequence_length:
            # –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –º–µ–Ω—å—à–µ, —á–µ–º –Ω—É–∂–Ω–æ, –∑–∞–ø–æ–ª–Ω—è–µ–º –Ω—É–ª—è–º–∏
            padding = np.zeros((self.sequence_length - len(self.current_data),) + self.current_data.shape[1:])
            return np.concatenate([self.current_data, padding], axis=0)
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –ë–ï–ó –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–æ–∑–∏—Ü–∏–∏
        obs = self.current_data[self.current_step].copy()
        return obs
    
    def _get_current_price(self):
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É –∑–∞–∫—Ä—ã—Ç–∏—è"""
        try:
            if self.current_data is None or len(self.current_data) == 0:
                return 100.0  # –ë–∞–∑–æ–≤–∞—è —Ü–µ–Ω–∞
            
            price = self.current_data[self.current_step][-1, 3]  # –∏–Ω–¥–µ–∫—Å 3 - —ç—Ç–æ 'close'
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —Ü–µ–Ω—ã
            if np.isnan(price) or np.isinf(price) or price <= 0:
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â—É—é —Ü–µ–Ω—É –∏–ª–∏ –±–∞–∑–æ–≤—É—é —Ü–µ–Ω—É
                if self.current_step > 0 and self.current_data is not None:
                    return self.current_data[self.current_step-1][-1, 3]
                else:
                    return 100.0  # –ë–∞–∑–æ–≤–∞—è —Ü–µ–Ω–∞
            
            return price
        except (IndexError, ValueError):
            return 100.0  # –ë–∞–∑–æ–≤–∞—è —Ü–µ–Ω–∞ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
    
    def _close_position(self, current_price):
        """–ó–∞–∫—Ä—ã–≤–∞–µ—Ç —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–ª—É—á–µ–Ω–Ω—É—é –Ω–∞–≥—Ä–∞–¥—É"""
        reward = 0
        
        try:
            if self.position == 1 and self.shares_held > 0:  # –ó–∞–∫—Ä—ã–≤–∞–µ–º –¥–ª–∏–Ω–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
                profit = self.shares_held * (current_price - self.cost_basis)
                fee = self.shares_held * current_price * self.transaction_fee
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ
                if not (np.isnan(profit) or np.isinf(profit) or np.isnan(fee) or np.isinf(fee)):
                    self.balance += self.shares_held * current_price - fee
                    reward = np.clip(profit / self.initial_balance, -10.0, 10.0)  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –Ω–∞–≥—Ä–∞–¥—É
                    self.total_profit += profit
            
            elif self.position == -1 and self.shares_held < 0:  # –ó–∞–∫—Ä—ã–≤–∞–µ–º –∫–æ—Ä–æ—Ç–∫—É—é –ø–æ–∑–∏—Ü–∏—é
                profit = -self.shares_held * (self.cost_basis - current_price)
                fee = -self.shares_held * current_price * self.transaction_fee
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ
                if not (np.isnan(profit) or np.isinf(profit) or np.isnan(fee) or np.isinf(fee)):
                    self.balance += profit - fee
                    reward = np.clip(profit / self.initial_balance, -10.0, 10.0)  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –Ω–∞–≥—Ä–∞–¥—É
                    self.total_profit += profit
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å –Ω–∞ —Ä–∞–∑—É–º–Ω–æ—Å—Ç—å
            if np.isnan(self.balance) or np.isinf(self.balance) or self.balance <= 0:
                self.balance = self.initial_balance * 0.1  # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å
                reward = -1.0  # –®—Ç—Ä–∞—Ñ –∑–∞ –±–∞–Ω–∫—Ä–æ—Ç—Å—Ç–≤–æ
            
        except (OverflowError, ValueError) as e:
            # –í —Å–ª—É—á–∞–µ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∫ –±–µ–∑–æ–ø–∞—Å–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏—è–º
            self.balance = self.initial_balance
            reward = -1.0
            # üî• –ò–ó–ú–ï–ù–ï–ù–û: self.logger.warning -> print
            print(f"–ü–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –ø–æ–∑–∏—Ü–∏–∏: {e}")
        
        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é
        self.shares_held = 0
        self.cost_basis = 0
        self.position = 0
        
        return reward

    def get_memory_stats(self):
        """üî• –î–û–ë–ê–í–õ–ï–ù–û: –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–∞–º—è—Ç–∏"""
        return {
            'buffer_size': len(self.memory_buffer),
            'max_size': self.memory_buffer.maxlen,
            'step_count': self.step_count,
            'memory_usage_percent': len(self.memory_buffer) / self.memory_buffer.maxlen * 100
        }
    
    def clear_old_memory(self, keep_last_n=100):
        """üî• –î–û–ë–ê–í–õ–ï–ù–û: –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö"""
        if len(self.memory_buffer) > keep_last_n:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ N –∑–∞–ø–∏—Å–µ–π
            recent_data = list(self.memory_buffer)[-keep_last_n:]
            self.memory_buffer.clear()
            self.memory_buffer.extend(recent_data)
            gc.collect()
            print(f"–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –ø–∞–º—è—Ç–∏, –æ—Å—Ç–∞–≤–ª–µ–Ω–æ {len(self.memory_buffer)} –∑–∞–ø–∏—Å–µ–π")