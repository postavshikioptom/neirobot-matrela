Основные библиотеки:
       * pybit: для взаимодействия с биржей Bybit.
       * pandas: для работы с данными (исторические котировки).
       * numpy: для математических вычислений.
       * scikit-learn: для классических моделей машинного обучения.
       * xgboost: для градиентного бустинга (часто показывает отличные результаты).
       * tensorflow и keras: для нейронных сетей.
       * pytorch: альтернатива Tensorflow.
       * matplotlib / plotly: для визуализации данных и результатов.

========
ФАЙЛЫ:
config.py для API-ключей.
data_loader.py для загрузки данных с Bybit.
simple_trader.py для самой простой торговой логики.
order_placer  / data_loader - выгружает данные по монете на 1 мин. таймфрейме и открывает ордер по простому сигналу - рост или падение по RSI
feature_engineering.py. - файл для индикаторов.
train_model.py - Загрузит features.csv.Подготовит данные для обучения (определит признаки и целевую переменную). Разделит данные на обучающую и тестовую выборки. Обучит модель XGBoost. Оценит производительность модели и построит графики для визуализации результатов.

НЕЙРОСЕТЬ
Среда (`trading_env.py`): Это будет симулятор нашего трейдинга. Он будет:
       * Подавать нейросети данные (например, последние 60 свечей).
       * Принимать от нейросети действия: Купить, Продать, Держать.
       * Рассчитывать награду (баллы) на основе результата действия, учитывая комиссию 0.08%
          на вход и выход из сделки.
       * Реализовывать вашу систему мотивации и штрафов.

не нужен - Агент (`rl_agent.py`): Это "мозг" нашего бота. Здесь будет:
вместо  rl_agent.py тперь stable-baselines3     
 * Сама нейросеть (например, на базе Keras/Tensorflow). Я предлагаю для начала
         использовать простую архитектуру, например, несколько слоев LSTM, так как они
         хорошо работают с последовательными данными, какими являются свечи.
       * Логика принятия решений на основе предсказаний нейросети (алгоритм, например, Deep
         Q-Network или DQN).
       * Механизм обучения: агент будет запоминать свои действия и их результаты (state,
         action, reward, next_state) и периодически обучаться на этом опыте, чтобы принимать
          более выгодные решения в будущем.

Тренировочный цикл (`train.py`): Главный скрипт, который будет:
       * Запускать среду и агента.
run_training.py - нужен, чтоб запускать train.py по частям чекпоинтам
       * Прогонять тысячи "эпизодов" (торговых сессий в симуляторе), в ходе которых агент
         будет набираться опыта.
       * Сохранять обученную модель агента для последующего использования в реальной
         торговле.
(evaluate_model.py) - дает нам поннять, как ведет себя модель на неизвестных для нее новых данных

====
ТОРГОВЛЯ НА BYBIT

run_live_trading.py  в бесконечном цикле управлет ВСЕМИ процессами в онлайн-трейдинге. 
запрашивает новые данные у live_data_provider.py.
Данные передаются в signal_generator_xgb.py. XGBoost говорит: "SELL".
Сигнал "SELL" передается в decision_maker_dqn.py.
decision_maker_dqn.py активируется, загружает свою DQN-модель, анализирует ситуацию и говорит: "CONFIRM".
Решение "CONFIRM SELL" уходит в trade_manager.py который выставляет ордер на продажу.
Вся информация об этом событии записывается в trade_logger.py.

СКРИННЕР BYBIT
screener.py
Объем предппоследней свечи в 1.5 раза больше последних 5-ти свечь
hotlists.txt - это выгрузка монет, которые на эту минуту выбрали для входа по Фильтрам
get_all_symbols.py - выгружает один раз все монеты на бирже  фьючерсов

==========
Комиссия за торговлю Bybit 0.08% от суммы ордера. Надо учитывать это и закладывать в прибыль, чтоб не торговать в 0.

=======
КАКИЕ СКРИПТЫ ЗАПУСКАТЬ ДЛЯ ОНЛАЙН ТОРГОВЛИ
.\\venv\Scripts\activate
python screener.py
python live_data_provider.py
python run_live_trading.py
====
СЕРВЕРА

kaggle_connect - для подключения к Kaggle по API и редактирования файлов, выгрузки и загрузки их
kaggle_notebook_code.txt - в него Gemini записывает ячейки, которые япотом вставляю в ноутбук neirobot-kaggle

