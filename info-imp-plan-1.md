# План улучшений для LSTM-бота торговли

## Диагностика текущих результатов
- Логи обучения: вал. точность ~0.513 и почти не растёт; потери колеблются около 0.692–0.693 → модель близка к рандому и/или лейблинг/фичи/валидация не дают сигнал.
- Бэктест: total_return ≈ -31%, Sharpe сильно отрицательный, PF≈0.92, win_rate≈0.48; включены force_trades=True, узкие TP/SL=1%, комиссия 0.11% за сторону → стратегия «переторговывает», расходы «съедают» результат.

## Цели
1) Устранить утечки и неверный лейблинг.
2) Перестроить обучение и валидацию (time-series CV) с таргетом, релевантным трейдингу.
3) Улучшить фичи и архитектуру.
4) Согласовать торговую логику и пороги с метриками, учитывающими комиссии и риск.

## План (10 ключевых улучшений)

### 1) Исключить утечки масштабирования (Quick Win)
- Что сделать:
  - Перестать масштабировать весь датасет заранее в `feature_engineering.py`.
  - Хранить «сырые» фичи; в `train_model.py` фитить `StandardScaler` только на train-части, затем трансформировать val/test и сохранять scaler.
- Почему: любые утечки (fit на всей выборке) бьют по обобщению и делают метрики недостоверными.
- Изменения: `feature_engineering.py`, `train_model.py`.

### 2) Перейти на Triple-Barrier Labeling (лейблинг сделок)
- Что сделать: вместо "sign(next return)" применить triple-barrier (TP/SL/временной барьер) для более реалистичных меток: +1/-1/0.
- Параметры на старт: tp=0.5–1.0% (верхний барьер), sl=0.5–1.0% (нижний), max_holding=60 баров; подбирать по CV.
- Источники:
  - Lopez de Prado: Triple-Barrier (обзор/гайд): https://wire.insiderfinance.io/triple-barrier-method-4cb60cf4c2f0
  - Объяснение и пример: https://www.newsletter.quantreo.com/p/the-triple-barrier-labeling-of-marco
  - Реализации/идеи: https://github.com/nkonts/barrier-method
- Изменения: новый модуль `labeling.py` или в `train_model.py` (формирование y до Dataset), обновить `SequenceDataset`.

### 3) Purged K-Fold + Embargo для подбора гиперпараметров
- Что сделать: ввести временную кросс-валидацию с "purging & embargo" при тюнинге (Optuna уже в окружении), чтобы исключить утечку информации во времени и автокорреляцию.
- Источники:
  - Объяснение: https://antonio-velazquez-bustamante.medium.com/kfold-cross-validation-with-purging-and-embargo-the-ultimate-cross-validation-technique-for-time-2d656ea6f476
  - Обсуждение CPCV: https://stats.stackexchange.com/questions/443159/what-is-combinatorial-purged-cross-validation-for-time-series-data
- Изменения: модуль `cv.py` (генератор сплитов), интеграция в `train_model.py` при тюнинге.

### 4) Калибровка вероятностей и оптимизация порога решения под доходность
- Что сделать:
  - Оценить калибровку (Reliability diagram). Применить Platt/Isotonic calibration на валидации.
  - Оптимизировать decision threshold не по accuracy, а по ожидаемой метрике (например, net return или utility) с учётом комиссий и проскальзывания.
- Изменения: `train_model.py` (калибровка и подбор порога), `simulation_engine.py` (использовать найденный порог).

### 5) Учёт дисбаланса и шумности таргета в функции потерь
- Что сделать: 
  - BCE с `pos_weight`/class weights по распределению меток triple-barrier.
  - Альтернатива: Focal Loss для фокусировки на трудных примерах; Label Smoothing 0.05–0.1.
- Изменения: `train_model.py`.

### 6) Архитектура и HPO
- Базовые варианты для сравнения: GRU, 1D-CNN+GRU, компактный Transformer-энкодер.
- Диапазоны HPO: lookback 50–200; hidden 64–256; num_layers 1–3; dropout 0.1–0.5; lr 1e-4–3e-3; weight_decay 0–1e-3.
- Лайфхаки: gradient clipping (e.g., 1.0), CosineAnnealingLR, Early Stopping по вал. utility.
- Изменения: `train_model.py`, добавить `hpo.py` (Optuna).

### 7) Фичи: добавить торгово-значимые признаки и производные
- Добавить:
  - Bollinger Bands (middle, upper, lower, %b, bandwidth), Donchian (20/55), ADX, SAR, Stoch RSI.
  - Лог-возвраты (1, 5, 10), кумулятивные ретёрны за окна; realized volatility (stdev ретёрнов), ATR нормированный.
  - Дельты и темпы изменений для текущих индикаторов (например, diff(EMA), diff(RSI)).
  - Режимные фичи: волатильностный режим (квантили vol), трендовый режим (EMA-cross state), SuperTrend direction (sign(supertrend - close)).
  - Rolling z-score цен/индикаторов (только по прошлому окну, без утечек).
- Важно: рассчитывать только на исторических окнах, без fit на будущем.
- Изменения: `feature_engineering.py`.

### 8) Исправить бэктест: реалистичность и логика сделок
- Убрать `force_trades=True` по умолчанию; оставить как отладочную опцию.
- Пересмотреть TP/SL (асимметрия, напр. TP 0.8%, SL 0.6%), trailing stop, max holding.
- Добавить проскальзывание (фикс. бпс), корректный учёт комиссий в PnL по каждой сделке.
- Исправить расчёт exposure (сейчас упрощён), вести индексный интервал открытой позиции.
- Изменения: `simulation_engine.py`.

### 9) Стратегический слой поверх модели (фильтры)
- Пример: входить только когда модельная вероятность > порога И тренд-фильтр согласован (EMA21>EMA50 или SuperTrend в ту же сторону), или исключать сделки при низкой волатильности.
- Динамический размер позиции по уверенности модели (например, линейно от |p-0.5|).
- Изменения: `simulation_engine.py` (логика сигналов/сайзинга).

### 10) Метрики и протокол оценки
- Метрика оптимизации: валидировать по expected return/Sharpe после транзакционных издержек (а не accuracy).
- Walk-Forward Evaluation: несколько периодов WF (train→val→test), обучение переносится во времени.
- Логи и артефакты: сохранять лучшие гиперпараметры, пороги, калибровку, отчёты.
- Изменения: `train_model.py`, `simulation_engine.py`, `logs`.

## Приоритизация и этапы
1) Быстрые правки (1, 8 частично): убрать утечки масштабирования, отключить force_trades, скорректировать exposure, добавить проскальзывание.
2) Лейблинг и валидация (2, 3, 4, 5): triple-barrier, purged CV, калибровка и пороги.
3) Фичи и модель (6, 7): новые признаки, HPO и альтернативные архитектуры.
4) Стратегический слой и итоговый WF-бэктест (9, 10).

## Минимальные технические изменения (эскизы)

```python
# train_model.py — масштабирование без утечки (эскиз)
scaler = StandardScaler()
X_train = scaler.fit_transform(features[:n_train])
X_val   = scaler.transform(features[n_train:])
# сохранить scaler в models/feature_scaler.pkl
```

```python
# labeling.py — triple-barrier (эскиз)
# y in {+1, 0, -1} в зависимости от того, какая граница сработала первой.
```

```python
# simulation_engine.py — отключить force_trades и улучшить пороги
cfg_sim = SimConfig(force_trades=False, max_tp_pct=0.008, max_sl_pct=0.006)
```

## Ожидаемый результат
- Устойчивые вневыборочные метрики (walk-forward): положительный Sharpe, PF>1, снижение turnover при росте net PnL.
- Контролируемая торговая частота, калиброванные пороги и меньшая чувствительность к комиссиям.

---
Примечание: отсутствует файл .zencoder/rules/repo.md — можем сгенерировать автоматически (описание структуры, цели, зависимости), это упростит дальнейшие рекомендации и навигацию по проекту.